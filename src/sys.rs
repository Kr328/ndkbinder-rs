/* automatically generated by rust-bindgen 0.69.1 */

#![allow(warnings, unused)]

#[link(name = "binder_ndk")]
extern "C" {}

pub const __BIONIC__: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __bos_level: u32 = 0;
pub const __ANDROID_API_FUTURE__: u32 = 10000;
pub const __ANDROID_API__: u32 = 10000;
pub const __ANDROID_API_G__: u32 = 9;
pub const __ANDROID_API_I__: u32 = 14;
pub const __ANDROID_API_J__: u32 = 16;
pub const __ANDROID_API_J_MR1__: u32 = 17;
pub const __ANDROID_API_J_MR2__: u32 = 18;
pub const __ANDROID_API_K__: u32 = 19;
pub const __ANDROID_API_L__: u32 = 21;
pub const __ANDROID_API_L_MR1__: u32 = 22;
pub const __ANDROID_API_M__: u32 = 23;
pub const __ANDROID_API_N__: u32 = 24;
pub const __ANDROID_API_N_MR1__: u32 = 25;
pub const __ANDROID_API_O__: u32 = 26;
pub const __ANDROID_API_O_MR1__: u32 = 27;
pub const __ANDROID_API_P__: u32 = 28;
pub const __ANDROID_API_Q__: u32 = 29;
pub const __ANDROID_API_R__: u32 = 30;
pub const __ANDROID_API_S__: u32 = 31;
pub const __ANDROID_API_T__: u32 = 33;
pub const __ANDROID_API_U__: u32 = 34;
pub const __ANDROID_NDK__: u32 = 1;
pub const __NDK_MAJOR__: u32 = 25;
pub const __NDK_MINOR__: u32 = 2;
pub const __NDK_BETA__: u32 = 0;
pub const __NDK_BUILD__: u32 = 9519653;
pub const __NDK_CANARY__: u32 = 0;
pub const __STD_UTF_16__: u32 = 1;
pub const __STD_UTF_32__: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;

pub type wchar_t = ::std::os::raw::c_int;

#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}

#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}

extern "C" {
    pub fn android_get_application_target_sdk_version() -> ::std::os::raw::c_int;
}

extern "C" {
    pub fn android_get_device_api_level() -> ::std::os::raw::c_int;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbstate_t {
    pub __seq: [::std::os::raw::c_uchar; 4usize],
    pub __reserved: [::std::os::raw::c_uchar; 4usize],
}

#[test]
fn bindgen_test_layout_mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mbstate_t>(),
        1usize,
        concat!("Alignment of ", stringify!(mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__seq) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(mbstate_t), "::", stringify!(__seq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(mbstate_t), "::", stringify!(__reserved))
    );
}

pub type char16_t = ::std::os::raw::c_ushort;
pub type char32_t = ::std::os::raw::c_uint;

extern "C" {
    pub fn c16rtomb(__buf: *mut ::std::os::raw::c_char, __ch16: char16_t, __ps: *mut mbstate_t) -> usize;
}

extern "C" {
    pub fn c32rtomb(__buf: *mut ::std::os::raw::c_char, __ch32: char32_t, __ps: *mut mbstate_t) -> usize;
}

extern "C" {
    pub fn mbrtoc16(__ch16: *mut char16_t, __s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}

extern "C" {
    pub fn mbrtoc32(__ch32: *mut char32_t, __s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}

pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __uintptr_t = ::std::os::raw::c_ulong;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_fast16_t = i64;
pub type uint_fast16_t = u64;
pub type int_fast32_t = i64;
pub type uint_fast32_t = u64;
pub type uintmax_t = u64;
pub type intmax_t = i64;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}

#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__kernel_fd_set), "::", stringify!(fds_bits))
    );
}

pub type __kernel_sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}

#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__kernel_fsid_t), "::", stringify!(val))
    );
}

pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub flags: u32,
    pub stack_base: *mut ::std::os::raw::c_void,
    pub stack_size: usize,
    pub guard_size: usize,
    pub sched_policy: i32,
    pub sched_priority: i32,
    pub __reserved: [::std::os::raw::c_char; 16usize],
}

#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_base) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(stack_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(stack_size))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guard_size) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(guard_size))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_policy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(sched_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(__reserved))
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_t {
    pub __private: [i64; 4usize],
}

#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__private)
        )
    );
}

pub type pthread_barrierattr_t = ::std::os::raw::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t {
    pub __private: [i32; 12usize],
}

#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(pthread_cond_t), "::", stringify!(__private))
    );
}

pub type pthread_condattr_t = ::std::os::raw::c_long;
pub type pthread_key_t = ::std::os::raw::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t {
    pub __private: [i32; 10usize],
}

#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(pthread_mutex_t), "::", stringify!(__private))
    );
}

pub type pthread_mutexattr_t = ::std::os::raw::c_long;
pub type pthread_once_t = ::std::os::raw::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t {
    pub __private: [i32; 14usize],
}

#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(pthread_rwlock_t), "::", stringify!(__private))
    );
}

pub type pthread_rwlockattr_t = ::std::os::raw::c_long;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock_t {
    pub __private: i64,
}

#[test]
fn bindgen_test_layout_pthread_spinlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_spinlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_spinlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_spinlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_spinlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_spinlock_t),
            "::",
            stringify!(__private)
        )
    );
}

pub type pthread_t = ::std::os::raw::c_long;
pub type __gid_t = __kernel_gid32_t;
pub type gid_t = __gid_t;
pub type __uid_t = __kernel_uid32_t;
pub type uid_t = __uid_t;
pub type __pid_t = __kernel_pid_t;
pub type pid_t = __pid_t;
pub type __id_t = u32;
pub type id_t = __id_t;
pub type blkcnt_t = ::std::os::raw::c_ulong;
pub type blksize_t = ::std::os::raw::c_ulong;
pub type caddr_t = __kernel_caddr_t;
pub type clock_t = __kernel_clock_t;
pub type __clockid_t = __kernel_clockid_t;
pub type clockid_t = __clockid_t;
pub type daddr_t = __kernel_daddr_t;
pub type fsblkcnt_t = ::std::os::raw::c_ulong;
pub type fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __mode_t = __kernel_mode_t;
pub type mode_t = __mode_t;
pub type __key_t = __kernel_key_t;
pub type key_t = __key_t;
pub type __ino_t = __kernel_ino_t;
pub type ino_t = __ino_t;
pub type ino64_t = u64;
pub type __nlink_t = u32;
pub type nlink_t = __nlink_t;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type timer_t = __timer_t;
pub type __suseconds_t = __kernel_suseconds_t;
pub type suseconds_t = __suseconds_t;
pub type __useconds_t = u32;
pub type useconds_t = __useconds_t;
pub type dev_t = u64;
pub type __time_t = __kernel_time_t;
pub type time_t = __time_t;
pub type off_t = i64;
pub type loff_t = off_t;
pub type off64_t = loff_t;
pub type __socklen_t = u32;
pub type socklen_t = __socklen_t;
pub type __va_list = __builtin_va_list;
pub type uint_t = ::std::os::raw::c_uint;
pub type uint = ::std::os::raw::c_uint;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type u_int32_t = u32;
pub type u_int16_t = u16;
pub type u_int8_t = u8;
pub type u_int64_t = u64;

extern "C" {
    pub fn __errno() -> *mut ::std::os::raw::c_int;
}

pub const STATUS_OK: _bindgen_ty_1 = 0;
pub const STATUS_UNKNOWN_ERROR: _bindgen_ty_1 = -2147483648;
pub const STATUS_NO_MEMORY: _bindgen_ty_1 = -12;
pub const STATUS_INVALID_OPERATION: _bindgen_ty_1 = -38;
pub const STATUS_BAD_VALUE: _bindgen_ty_1 = -22;
pub const STATUS_BAD_TYPE: _bindgen_ty_1 = -2147483647;
pub const STATUS_NAME_NOT_FOUND: _bindgen_ty_1 = -2;
pub const STATUS_PERMISSION_DENIED: _bindgen_ty_1 = -1;
pub const STATUS_NO_INIT: _bindgen_ty_1 = -19;
pub const STATUS_ALREADY_EXISTS: _bindgen_ty_1 = -17;
pub const STATUS_DEAD_OBJECT: _bindgen_ty_1 = -32;
pub const STATUS_FAILED_TRANSACTION: _bindgen_ty_1 = -2147483646;
pub const STATUS_BAD_INDEX: _bindgen_ty_1 = -75;
pub const STATUS_NOT_ENOUGH_DATA: _bindgen_ty_1 = -61;
pub const STATUS_WOULD_BLOCK: _bindgen_ty_1 = -11;
pub const STATUS_TIMED_OUT: _bindgen_ty_1 = -110;
pub const STATUS_UNKNOWN_TRANSACTION: _bindgen_ty_1 = -74;
pub const STATUS_FDS_NOT_ALLOWED: _bindgen_ty_1 = -2147483641;
pub const STATUS_UNEXPECTED_NULL: _bindgen_ty_1 = -2147483640;

pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub type binder_status_t = i32;

pub const EX_NONE: _bindgen_ty_2 = 0;
pub const EX_SECURITY: _bindgen_ty_2 = -1;
pub const EX_BAD_PARCELABLE: _bindgen_ty_2 = -2;
pub const EX_ILLEGAL_ARGUMENT: _bindgen_ty_2 = -3;
pub const EX_NULL_POINTER: _bindgen_ty_2 = -4;
pub const EX_ILLEGAL_STATE: _bindgen_ty_2 = -5;
pub const EX_NETWORK_MAIN_THREAD: _bindgen_ty_2 = -6;
pub const EX_UNSUPPORTED_OPERATION: _bindgen_ty_2 = -7;
pub const EX_SERVICE_SPECIFIC: _bindgen_ty_2 = -8;
pub const EX_PARCELABLE: _bindgen_ty_2 = -9;
pub const EX_TRANSACTION_FAILED: _bindgen_ty_2 = -129;

pub type _bindgen_ty_2 = ::std::os::raw::c_int;
pub type binder_exception_t = i32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AStatus {
    _unused: [u8; 0],
}

extern "C" {
    pub fn AStatus_newOk() -> *mut AStatus;
}

extern "C" {
    pub fn AStatus_fromExceptionCode(exception: binder_exception_t) -> *mut AStatus;
}

extern "C" {
    pub fn AStatus_fromExceptionCodeWithMessage(
        exception: binder_exception_t,
        message: *const ::std::os::raw::c_char,
    ) -> *mut AStatus;
}

extern "C" {
    pub fn AStatus_fromServiceSpecificError(serviceSpecific: i32) -> *mut AStatus;
}

extern "C" {
    pub fn AStatus_fromServiceSpecificErrorWithMessage(
        serviceSpecific: i32,
        message: *const ::std::os::raw::c_char,
    ) -> *mut AStatus;
}

extern "C" {
    pub fn AStatus_fromStatus(status: binder_status_t) -> *mut AStatus;
}

extern "C" {
    pub fn AStatus_isOk(status: *const AStatus) -> bool;
}

extern "C" {
    pub fn AStatus_getExceptionCode(status: *const AStatus) -> binder_exception_t;
}

extern "C" {
    pub fn AStatus_getServiceSpecificError(status: *const AStatus) -> i32;
}

extern "C" {
    pub fn AStatus_getStatus(status: *const AStatus) -> binder_status_t;
}

extern "C" {
    pub fn AStatus_getMessage(status: *const AStatus) -> *const ::std::os::raw::c_char;
}

extern "C" {
    pub fn AStatus_getDescription(status: *const AStatus) -> *const ::std::os::raw::c_char;
}

extern "C" {
    pub fn AStatus_deleteDescription(description: *const ::std::os::raw::c_char);
}

extern "C" {
    pub fn AStatus_delete(status: *mut AStatus);
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AParcel {
    _unused: [u8; 0],
}

extern "C" {
    pub fn AParcel_delete(parcel: *mut AParcel);
}

extern "C" {
    pub fn AParcel_setDataPosition(parcel: *const AParcel, position: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_getDataPosition(parcel: *const AParcel) -> i32;
}

pub type AParcel_stringAllocator = ::std::option::Option<
    unsafe extern "C" fn(stringData: *mut ::std::os::raw::c_void, length: i32, buffer: *mut *mut ::std::os::raw::c_char) -> bool,
>;
pub type AParcel_stringArrayAllocator =
    ::std::option::Option<unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool>;
pub type AParcel_stringArrayElementAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        index: usize,
        length: i32,
        buffer: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
pub type AParcel_stringArrayElementGetter = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *const ::std::os::raw::c_void,
        index: usize,
        outLength: *mut i32,
    ) -> *const ::std::os::raw::c_char,
>;
pub type AParcel_parcelableArrayAllocator =
    ::std::option::Option<unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool>;
pub type AParcel_writeParcelableElement = ::std::option::Option<
    unsafe extern "C" fn(parcel: *mut AParcel, arrayData: *const ::std::os::raw::c_void, index: usize) -> binder_status_t,
>;
pub type AParcel_readParcelableElement = ::std::option::Option<
    unsafe extern "C" fn(parcel: *const AParcel, arrayData: *mut ::std::os::raw::c_void, index: usize) -> binder_status_t,
>;
pub type AParcel_int32ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32, outBuffer: *mut *mut i32) -> bool,
>;
pub type AParcel_uint32ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32, outBuffer: *mut *mut u32) -> bool,
>;
pub type AParcel_int64ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32, outBuffer: *mut *mut i64) -> bool,
>;
pub type AParcel_uint64ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32, outBuffer: *mut *mut u64) -> bool,
>;
pub type AParcel_floatArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32, outBuffer: *mut *mut f32) -> bool,
>;
pub type AParcel_doubleArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32, outBuffer: *mut *mut f64) -> bool,
>;
pub type AParcel_boolArrayAllocator =
    ::std::option::Option<unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool>;
pub type AParcel_boolArrayGetter =
    ::std::option::Option<unsafe extern "C" fn(arrayData: *const ::std::os::raw::c_void, index: usize) -> bool>;
pub type AParcel_boolArraySetter =
    ::std::option::Option<unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, index: usize, value: bool)>;
pub type AParcel_charArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32, outBuffer: *mut *mut char16_t) -> bool,
>;
pub type AParcel_byteArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32, outBuffer: *mut *mut i8) -> bool,
>;

extern "C" {
    pub fn AParcel_writeStrongBinder(parcel: *mut AParcel, binder: *mut AIBinder) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readStrongBinder(parcel: *const AParcel, binder: *mut *mut AIBinder) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeParcelFileDescriptor(parcel: *mut AParcel, fd: ::std::os::raw::c_int) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readParcelFileDescriptor(parcel: *const AParcel, fd: *mut ::std::os::raw::c_int) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeStatusHeader(parcel: *mut AParcel, status: *const AStatus) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readStatusHeader(parcel: *const AParcel, status: *mut *mut AStatus) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeString(parcel: *mut AParcel, string: *const ::std::os::raw::c_char, length: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readString(
        parcel: *const AParcel,
        stringData: *mut ::std::os::raw::c_void,
        allocator: AParcel_stringAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeStringArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        getter: AParcel_stringArrayElementGetter,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readStringArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_stringArrayAllocator,
        elementAllocator: AParcel_stringArrayElementAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeParcelableArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        elementWriter: AParcel_writeParcelableElement,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readParcelableArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_parcelableArrayAllocator,
        elementReader: AParcel_readParcelableElement,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeInt32(parcel: *mut AParcel, value: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeUint32(parcel: *mut AParcel, value: u32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeInt64(parcel: *mut AParcel, value: i64) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeUint64(parcel: *mut AParcel, value: u64) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeFloat(parcel: *mut AParcel, value: f32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeDouble(parcel: *mut AParcel, value: f64) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeBool(parcel: *mut AParcel, value: bool) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeChar(parcel: *mut AParcel, value: char16_t) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeByte(parcel: *mut AParcel, value: i8) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readInt32(parcel: *const AParcel, value: *mut i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readUint32(parcel: *const AParcel, value: *mut u32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readInt64(parcel: *const AParcel, value: *mut i64) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readUint64(parcel: *const AParcel, value: *mut u64) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readFloat(parcel: *const AParcel, value: *mut f32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readDouble(parcel: *const AParcel, value: *mut f64) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readBool(parcel: *const AParcel, value: *mut bool) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readChar(parcel: *const AParcel, value: *mut char16_t) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readByte(parcel: *const AParcel, value: *mut i8) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeInt32Array(parcel: *mut AParcel, arrayData: *const i32, length: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeUint32Array(parcel: *mut AParcel, arrayData: *const u32, length: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeInt64Array(parcel: *mut AParcel, arrayData: *const i64, length: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeUint64Array(parcel: *mut AParcel, arrayData: *const u64, length: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeFloatArray(parcel: *mut AParcel, arrayData: *const f32, length: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeDoubleArray(parcel: *mut AParcel, arrayData: *const f64, length: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeBoolArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        getter: AParcel_boolArrayGetter,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeCharArray(parcel: *mut AParcel, arrayData: *const char16_t, length: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_writeByteArray(parcel: *mut AParcel, arrayData: *const i8, length: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readInt32Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_int32ArrayAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readUint32Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_uint32ArrayAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readInt64Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_int64ArrayAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readUint64Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_uint64ArrayAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readFloatArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_floatArrayAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readDoubleArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_doubleArrayAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readBoolArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_boolArrayAllocator,
        setter: AParcel_boolArraySetter,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readCharArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_charArrayAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_readByteArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_byteArrayAllocator,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_reset(parcel: *mut AParcel) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_getDataSize(parcel: *const AParcel) -> i32;
}

extern "C" {
    pub fn AParcel_appendFrom(from: *const AParcel, to: *mut AParcel, start: i32, size: i32) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_create() -> *mut AParcel;
}

extern "C" {
    pub fn AParcel_marshal(parcel: *const AParcel, buffer: *mut u8, start: usize, len: usize) -> binder_status_t;
}

extern "C" {
    pub fn AParcel_unmarshal(parcel: *mut AParcel, buffer: *const u8, len: usize) -> binder_status_t;
}

pub type binder_flags_t = u32;

pub const FLAG_ONEWAY: _bindgen_ty_3 = 1;

pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub type transaction_code_t = u32;

pub const FIRST_CALL_TRANSACTION: _bindgen_ty_4 = 1;
pub const LAST_CALL_TRANSACTION: _bindgen_ty_4 = 16777215;

pub type _bindgen_ty_4 = ::std::os::raw::c_uint;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_Class {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_Weak {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_DeathRecipient {
    _unused: [u8; 0],
}

pub type AIBinder_Class_onCreate =
    ::std::option::Option<unsafe extern "C" fn(args: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void>;
pub type AIBinder_Class_onDestroy = ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
pub type AIBinder_Class_onTransact = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        code: transaction_code_t,
        in_: *const AParcel,
        out: *mut AParcel,
    ) -> binder_status_t,
>;

extern "C" {
    pub fn AIBinder_Class_define(
        interfaceDescriptor: *const ::std::os::raw::c_char,
        onCreate: AIBinder_Class_onCreate,
        onDestroy: AIBinder_Class_onDestroy,
        onTransact: AIBinder_Class_onTransact,
    ) -> *mut AIBinder_Class;
}

pub type AIBinder_onDump = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        fd: ::std::os::raw::c_int,
        args: *mut *const ::std::os::raw::c_char,
        numArgs: u32,
    ) -> binder_status_t,
>;

extern "C" {
    pub fn AIBinder_Class_setOnDump(clazz: *mut AIBinder_Class, onDump: AIBinder_onDump);
}

extern "C" {
    pub fn AIBinder_Class_disableInterfaceTokenHeader(clazz: *mut AIBinder_Class);
}

extern "C" {
    pub fn AIBinder_new(clazz: *const AIBinder_Class, args: *mut ::std::os::raw::c_void) -> *mut AIBinder;
}

extern "C" {
    pub fn AIBinder_isRemote(binder: *const AIBinder) -> bool;
}

extern "C" {
    pub fn AIBinder_isAlive(binder: *const AIBinder) -> bool;
}

extern "C" {
    pub fn AIBinder_ping(binder: *mut AIBinder) -> binder_status_t;
}

extern "C" {
    pub fn AIBinder_dump(
        binder: *mut AIBinder,
        fd: ::std::os::raw::c_int,
        args: *mut *const ::std::os::raw::c_char,
        numArgs: u32,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AIBinder_linkToDeath(
        binder: *mut AIBinder,
        recipient: *mut AIBinder_DeathRecipient,
        cookie: *mut ::std::os::raw::c_void,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AIBinder_unlinkToDeath(
        binder: *mut AIBinder,
        recipient: *mut AIBinder_DeathRecipient,
        cookie: *mut ::std::os::raw::c_void,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AIBinder_getCallingUid() -> uid_t;
}

extern "C" {
    pub fn AIBinder_getCallingPid() -> pid_t;
}

extern "C" {
    pub fn AIBinder_isHandlingTransaction() -> bool;
}

extern "C" {
    pub fn AIBinder_incStrong(binder: *mut AIBinder);
}

extern "C" {
    pub fn AIBinder_decStrong(binder: *mut AIBinder);
}

extern "C" {
    pub fn AIBinder_debugGetRefCount(binder: *mut AIBinder) -> i32;
}

extern "C" {
    pub fn AIBinder_associateClass(binder: *mut AIBinder, clazz: *const AIBinder_Class) -> bool;
}

extern "C" {
    pub fn AIBinder_getClass(binder: *mut AIBinder) -> *const AIBinder_Class;
}

extern "C" {
    pub fn AIBinder_getUserData(binder: *mut AIBinder) -> *mut ::std::os::raw::c_void;
}

extern "C" {
    pub fn AIBinder_prepareTransaction(binder: *mut AIBinder, in_: *mut *mut AParcel) -> binder_status_t;
}

extern "C" {
    pub fn AIBinder_transact(
        binder: *mut AIBinder,
        code: transaction_code_t,
        in_: *mut *mut AParcel,
        out: *mut *mut AParcel,
        flags: binder_flags_t,
    ) -> binder_status_t;
}

extern "C" {
    pub fn AIBinder_Weak_new(binder: *mut AIBinder) -> *mut AIBinder_Weak;
}

extern "C" {
    pub fn AIBinder_Weak_delete(weakBinder: *mut AIBinder_Weak);
}

extern "C" {
    pub fn AIBinder_Weak_promote(weakBinder: *mut AIBinder_Weak) -> *mut AIBinder;
}

pub type AIBinder_DeathRecipient_onBinderDied = ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
pub type AIBinder_DeathRecipient_onBinderUnlinked =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;

extern "C" {
    pub fn AIBinder_DeathRecipient_new(onBinderDied: AIBinder_DeathRecipient_onBinderDied) -> *mut AIBinder_DeathRecipient;
}

extern "C" {
    pub fn AIBinder_DeathRecipient_setOnUnlinked(
        recipient: *mut AIBinder_DeathRecipient,
        onUnlinked: AIBinder_DeathRecipient_onBinderUnlinked,
    );
}

extern "C" {
    pub fn AIBinder_DeathRecipient_delete(recipient: *mut AIBinder_DeathRecipient);
}

extern "C" {
    pub fn AIBinder_getExtension(binder: *mut AIBinder, outExt: *mut *mut AIBinder) -> binder_status_t;
}

extern "C" {
    pub fn AIBinder_setExtension(binder: *mut AIBinder, ext: *mut AIBinder) -> binder_status_t;
}

extern "C" {
    pub fn AIBinder_Class_getDescriptor(clazz: *const AIBinder_Class) -> *const ::std::os::raw::c_char;
}

extern "C" {
    pub fn AIBinder_lt(lhs: *const AIBinder, rhs: *const AIBinder) -> bool;
}

extern "C" {
    pub fn AIBinder_Weak_clone(weak: *const AIBinder_Weak) -> *mut AIBinder_Weak;
}

extern "C" {
    pub fn AIBinder_Weak_lt(lhs: *const AIBinder_Weak, rhs: *const AIBinder_Weak) -> bool;
}

pub type __builtin_va_list = [__va_list_tag; 1usize];

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}

#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(gp_offset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(fp_offset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
